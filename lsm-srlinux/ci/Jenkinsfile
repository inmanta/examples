/**
* Set the repo URL in the project.yml, that references the private Python package repository, correctly based on the
* given iso version and token.
*
* @param isoProductVersion: The version of the inmanta-service-orchestrator Python package of the orchestrator we are running against.
* @param token: The token to connect to the private Python package repository for the Inmanta project.
*/
def update_project_yml(String isoProductVersion, String token) {
    def pythonPackageRepoUrl = ""
    if(isoProductVersion.endsWith("dev")){
        pythonPackageRepoUrl = "https://artifacts.internal.inmanta.com/inmanta/dev"
    } else{
        def majorVersion = isoProductVersion.split('\\.')[0]
        pythonPackageRepoUrl = "https://packages.inmanta.com/${token}/inmanta-service-orchestrator-${majorVersion}-stable/python/simple/"
    }
    def fileName = "${env.WORKSPACE}/lsm-srlinux/project.yml"
    def yamlDct = readYaml file: fileName
    yamlDct['repo'][0]['url'] = pythonPackageRepoUrl
    writeYaml file: fileName, data: yamlDct, overwrite: true
}


/**
* Updates the topology.yml so that the lab environment
* uses the same version as the specified Python package of the ISO product.
*
* @param isoProductVersion: The version of the inmanta-service-orchestrator Python package of the orchestrator we are running against.
*/
def update_topology(String isoProductVersion) {
    def dockerImageUrl = convert_iso_version_to_docker_image_url(isoProductVersion)
    def fileName = "${env.WORKSPACE}/lsm-srlinux/containerlab/topology.yml"
    def yamlDct = readYaml file: fileName
    yamlDct['topology']['nodes']['inmanta-server']['image'] = dockerImageUrl
    writeYaml file: fileName, data: yamlDct, overwrite: true
}


/**
* Convert the version of the inmanta-service-orchestrator Python package to a URL that references a docker image.
*
* @param isoProductVersion: The version of the inmanta-service-orchestrator Python package of the orchestrator we are running against.
*/
def convert_iso_version_to_docker_image_url(String isoProductVersion) {
    def matcher = isoProductVersion =~ /(\d+)/
    // Is it a version number consisting of a single number
    if (matcher.matches()) {
        return "containers.inmanta.com/containers/service-orchestrator:${isoProductVersion}"
    }
    matcher = isoProductVersion =~ /(\d+)dev/
    // It's a development version
    if (matcher.matches()) {
        return "code.inmanta.com:4567/solutions/containers/service-orchestrator:${matcher.group(1)}-dev"
    }
    // Is it a three-dotted version number
    matcher = isoProductVersion =~ /(\d+)\.(\d+)\.(\d+)(rc)?(\d*)/
    if (matcher.matches()) {
        def major = matcher.group(1)
        def minor = matcher.group(2)
        def patch = matcher.group(3)
        def isRcVersion = matcher.group(4)
        def formattedVersion = "${major}.${minor}.${patch}"
        if (isRcVersion) {
            formattedVersion += "-rc"
        }
        return "containers.inmanta.com/containers/service-orchestrator:${formattedVersion}"
    } else {
        error("Invalid version format: ${isoProductVersion}")
    }
}


/**
* Returns the script that tears down the lab environment.
*
* @param strict: If false, allow the cleanup to fail, e.g. because the containers do not yet exist.
*/
def get_tear_down_script(boolean strict = true) {
   return """
       cd '${env.WORKSPACE}/lsm-srlinux'
       sudo clab destroy --cleanup -t containerlab/topology.yml ${strict ? '' : '|| true'}
   """
}


pipeline {
    agent any

    parameters {
        string(name: 'version', defaultValue: '7dev', description: 'Run the lsm quickstart against the specified version of ISO product. The version can be of format 6.1.1rc20230217144359, 6.1.1rc, 6.1.1, 6 or 6dev.')
    }

    environment {
        PIP_INDEX_URL='https://artifacts.internal.inmanta.com/inmanta/dev'
    }

    triggers {
        parameterizedCron(BRANCH_NAME == 'master' ? "H H(2-5) * * * " : "")
    }

    options {
        disableConcurrentBuilds()
        skipDefaultCheckout()
    }

    stages {
        stage('Cleanup') {
            steps {
                deleteDir()
                checkout scm
                withCredentials([
                    file(credentialsId: 'JENKINS_JWE', variable: 'ENTITLEMENTS_FILE'),
                    file(credentialsId: 'JENKINS_LICENSE', variable: 'LICENSE_KEY_FILE'),
                ]) {
                    sh '''
                        cd "${WORKSPACE}/lsm-srlinux/containerlab"
                        # The `clab destroy` command expects the com.inmanta.jwe and
                        # com.inmanta.license files to exist in disk.
                        mkdir resources
                        cp "${ENTITLEMENTS_FILE}" resources/com.inmanta.jwe
                        cp "${LICENSE_KEY_FILE}" resources/com.inmanta.license
                        # The inmanta container is running as a different user then Jenkins
                        chmod 444 resources/com.inmanta.jwe resources/com.inmanta.license
                    '''
                }
                script {
                    // Cleanup before starting
                    sh(script: get_tear_down_script(false))
                }
            }
        }
        stage('Build') {
            options {
                timeout(time: 1, unit: 'HOURS')
            }
            steps {
                script {
                    withCredentials([
                        // Credentials to access the inmanta-service-orchestrator-* repositories on Cloudsmith.
                        string(
                            credentialsId: "cloudsmith-token",
                            variable: "CLOUDSMITH_PKGS_TOKEN",
                        ),
                    ]) {
                        // update_topology validates whether the given version has a valid format
                        update_topology(env.version)
                        update_project_yml(env.version, env.CLOUDSMITH_PKGS_TOKEN)
                        sh '''
                            cd "${WORKSPACE}/lsm-srlinux"
                            # Ensure we have the latest version of the srlinux image
                            sudo docker pull ghcr.io/nokia/srlinux:latest

                            sudo clab deploy -t containerlab/topology.yml --reconfigure
                            # Get python version used to build the container
                            python_version=$(docker inspect --format='{{range .Config.Env}}{{println .}}{{end}}' clab-srlinux-inmanta-server | grep -P "^PYTHON_VERSION=" | sed 's/[^=]*=//')

                            # Create python environment
                            python${python_version} -m venv venv
                            source "venv/bin/activate"
                            pip install -U pip

                            # Get inmanta version from the container
                            inmanta_version=$(docker inspect --format='{{index .Config.Labels "com.inmanta.version"}}' clab-srlinux-inmanta-server)
                            echo "inm_version=$inmanta_version"
                            if [[ ${version} == *dev ]]; then
                                constraint="~=${version::-3}.0.dev"
                            else
                                # Make sure we're using the right version for the product.
                                # e.g. if env.version==6, we can use it to get the container since the latest image for this version is always tagged '6'
                                # but we can't use it as is for the product because it would be interpreted as '6.0.0' which is not the latest version.
                                constraint="==${inmanta_version}"
                            fi
                            # install inmanta-dev-dependencies[extension] rather than pytest-inmanta-extensions directly to
                            # help pip find matching candidates (see inmanta/infra-tickets#180)
                            pip install "inmanta-service-orchestrator${constraint}" inmanta-dev-dependencies[extension]

                            python -u ci/do_test_deployment_and_verify.py
                        '''
                    }
                }
            }
        }
    }
    post {
        always {
            script{
                sh(script: get_tear_down_script())
            }
            deleteDir()
        }
    }
}

